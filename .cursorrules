# Learning AI Assistant - Cursor Rules

## Project Overview
This is a Learning AI Assistant that logs chat conversations from Telegram and Discord platforms using Node.js, Express, Supabase, and Bootstrap. The goal is to collect conversation data for future AI training.

## Technology Stack
- **Backend**: Node.js with Express.js
- **Database**: Supabase (PostgreSQL)
- **Bot Platforms**: Telegram Bot API, Discord.js
- **Frontend**: Bootstrap 5 + Vanilla JavaScript
- **Environment**: dotenv for configuration

## Project Structure
```
learning-ai-assistant/
├── backend/
│   ├── index.js             # Express server entry point
│   ├── telegram.js          # Telegram bot logic
│   ├── discord.js           # Discord bot logic
│   ├── supabase.js          # Supabase client configuration
│   ├── routes/
│   │   └── chats.js         # API endpoints for chat data
│   └── .env.example         # Environment variables template
├── dashboard/
│   ├── index.html           # Bootstrap dashboard
│   └── main.js              # Frontend JavaScript
└── README.md
```

## Code Style & Standards

### General Guidelines
- Use modern ES6+ JavaScript features (async/await, destructuring, arrow functions)
- Use camelCase for variables and functions
- Use PascalCase for classes and constructors
- Use UPPER_SNAKE_CASE for constants and environment variables
- Add JSDoc comments for complex functions
- Handle errors properly with try-catch blocks
- Use meaningful variable and function names

### Backend Development
- Always use `async/await` instead of callbacks or `.then()`
- Implement proper error handling middleware in Express
- Use environment variables for all sensitive data
- Structure Express routes in separate files under `routes/`
- Use middleware for common functionality (logging, authentication, CORS)
- Validate input data before processing
- Return consistent JSON response formats

### Database (Supabase)
- Use prepared statements and parameterized queries
- Implement proper error handling for database operations
- Use transactions for related operations
- Create indexes for frequently queried columns
- Follow naming conventions: snake_case for tables and columns
- Store timestamps in UTC format
- Use proper data types (JSONB for flexible data, TEXT for messages)

### Bot Development
- Handle rate limiting properly for both Telegram and Discord APIs
- Implement graceful error handling for API failures
- Log all important events and errors
- Use webhook mode for production Telegram bots
- Implement proper message parsing and validation
- Store raw message data for future processing

### Frontend Development
- Use Bootstrap 5 classes consistently
- Implement responsive design principles
- Use fetch API for HTTP requests with proper error handling
- Implement client-side search and filtering
- Use semantic HTML elements
- Add loading states for async operations

## Environment Variables
Required environment variables (document in .env.example):
```
# Supabase Configuration
SUPABASE_URL=your_supabase_url
SUPABASE_ANON_KEY=your_supabase_anon_key
SUPABASE_SERVICE_KEY=your_supabase_service_key

# Bot Tokens
TELEGRAM_BOT_TOKEN=your_telegram_bot_token
DISCORD_BOT_TOKEN=your_discord_bot_token

# Server Configuration
PORT=3000
NODE_ENV=development
```

## Database Schema Guidelines
```sql
-- Messages table structure
CREATE TABLE messages (
  id BIGSERIAL PRIMARY KEY,
  platform VARCHAR(20) NOT NULL, -- 'telegram' or 'discord'
  platform_message_id VARCHAR(100),
  user_id VARCHAR(100),
  username VARCHAR(100),
  message_text TEXT,
  message_type VARCHAR(50), -- 'user' or 'bot'
  thread_id VARCHAR(100),
  chat_id VARCHAR(100),
  raw_data JSONB, -- Store complete message object
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

## API Design Patterns
- Use RESTful conventions for endpoints
- Return consistent response formats:
  ```json
  {
    "success": true,
    "data": [...],
    "pagination": { "page": 1, "limit": 50, "total": 1000 },
    "message": "Optional success message"
  }
  ```
- For errors:
  ```json
  {
    "success": false,
    "error": "Error message",
    "code": "ERROR_CODE"
  }
  ```

## Security Best Practices
- Never commit API keys or tokens to version control
- Use HTTPS in production
- Implement rate limiting on API endpoints
- Validate and sanitize all user inputs
- Use CORS appropriately
- Store sensitive data encrypted in the database
- Implement proper authentication for admin endpoints

## Performance Guidelines
- Use connection pooling for database connections
- Implement pagination for large datasets
- Use caching where appropriate (Redis for production)
- Optimize database queries with proper indexes
- Implement request/response compression
- Use CDN for static assets in production

## Error Handling
- Always wrap async operations in try-catch blocks
- Log errors with appropriate context (user ID, action, timestamp)
- Return user-friendly error messages
- Implement global error handling middleware in Express
- Use proper HTTP status codes
- Monitor error rates and patterns

## Testing Guidelines (Future Implementation)
- Write unit tests for core business logic
- Test API endpoints with different input scenarios
- Mock external API calls (Telegram, Discord, Supabase)
- Test error handling scenarios
- Use environment-specific test databases

## Development Workflow
1. Start with .env.example and create your .env file
2. Set up Supabase database and tables
3. Test bot connections before implementing logging
4. Implement one platform at a time (Telegram first, then Discord)
5. Test API endpoints with sample data
6. Build dashboard incrementally with real data

## Common Patterns

### Message Logging Pattern
```javascript
async function logMessage(platform, messageData) {
  try {
    const normalizedMessage = normalizeMessage(platform, messageData);
    const { data, error } = await supabase
      .from('messages')
      .insert(normalizedMessage);
    
    if (error) throw error;
    return data;
  } catch (error) {
    console.error(`Failed to log ${platform} message:`, error);
    throw error;
  }
}
```

### Error Response Pattern
```javascript
app.use((error, req, res, next) => {
  console.error('Express error:', error);
  res.status(error.status || 500).json({
    success: false,
    error: error.message || 'Internal server error',
    code: error.code || 'INTERNAL_ERROR'
  });
});
```

## Documentation Requirements
- Update README.md with setup instructions
- Document all API endpoints with examples
- Include troubleshooting section for common issues
- Document environment variable requirements
- Provide sample .env.example file 